import socket
import sys
import struct
import threading

def checksum(data):
    """Calculate the checksum of the given data."""
    if len(data) % 2 != 0:
        data += b'\x00'  # Pad with a zero byte if the length is odd

    s = 0
    for i in range(0, len(data), 2):
        w = (data[i] << 8) + data[i + 1]
        s = s + w

    # Add overflow bits to the sum
    s = (s >> 16) + (s & 0xFFFF)
    s = ~s & 0xFFFF

    return s

def icmp_create(icmp_type, icmp_code, icmp_id, icmp_sequence, data):
    """Create an ICMP packet with the given parameters and return it."""
    icmp_checksum = 0  # Initially, the checksum is set to 0
    icmp_header = struct.pack("!BBHHH", icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_sequence)
    icmp_packet = icmp_header + data

    # Calculate the checksum
    icmp_checksum = checksum(icmp_packet)
    
    # Pack the header again with the correct checksum
    icmp_header = struct.pack("!BBHHH", icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_sequence)
    return icmp_header + data

def ping(src, dst, count):
    """Send ICMP packets."""
    # IP header fields
    ip_ihl = 5
    ip_ver = 4
    ip_tos = 0
    ip_len = 0  # Kernel will fill the correct total length
    ip_id = 54321  # ID of this packet
    ip_frag_off = 0
    ip_ttl = 64
    ip_proto = 1  # ICMP
    ip_check = 0  # Kernel will fill the correct checksum
    ip_saddr = socket.inet_aton(src)
    ip_daddr = socket.inet_aton(dst)

    # ICMP header fields
    icmp_type = 8  # Echo request
    icmp_code = 0
    icmp_id = 0
    icmp_sequence = 0
    payload = b'!@#$%^&*() 1234567890'

    ip_ihl_ver = (ip_ver << 4) + ip_ihl

    # Packing the IP header
    ip_header = struct.pack(
        "!BBHHHBBH4s4s", ip_ihl_ver, ip_tos, ip_len, ip_id, ip_frag_off,
        ip_ttl, ip_proto, ip_check, ip_saddr, ip_daddr
    )
    icmp_header = icmp_create(icmp_type, icmp_code, icmp_id, icmp_sequence, payload)
    packet = ip_header + icmp_header

    # Send ICMP packets
    print(f"PING {dst} bytes of data.")
    for _ in range(count):
        sendsock.sendto(packet, (dst, 0))
        time.sleep(1)  # To avoid sending packets too quickly

def capture():
    """Capture and print incoming ICMP packets."""
    s = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0800))
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(("eth0", 0))  # Change "eth0" to your network interface

    try:
        while True:
            # Reading Packet
            resp = s.recvfrom(65565)[0]
            ip_header = resp[14:34]
            ip = struct.unpack("!BBHHHBBH4s4s", ip_header)

            ip_proto = ip[6]
            if ip_proto == 1:  # ICMP
                src_address = socket.inet_ntoa(ip[8])
                dst_address = socket.inet_ntoa(ip[9])
                print(f"Received ICMP packet from {src_address} to {dst_address}")
    except KeyboardInterrupt:
        print("Capture stopped.")

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: ping <src ip> <dst ip> <count>")
        sys.exit(1)

    src = sys.argv[1]
    dst = sys.argv[2]
    count = int(sys.argv[3])

    # Creating raw socket for sending packets
    sendsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
    sendsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sendsock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)

    # Starting threads for sending and receiving packets
    ping_thread = threading.Thread(target=ping, args=(src, dst, count))
    capture_thread = threading.Thread(target=capture)

    ping_thread.start()
    capture_thread.start()

    ping_thread.join()
    capture_thread.join()

