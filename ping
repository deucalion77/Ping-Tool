#! /usr/bin/python

from ctypes import *
import socket
import sys
import time
from struct import *
import struct
import threading

def checksum(data):
    """Calculate the checksum of the given data."""
    if len(data) % 2 != 0:
        data += b'\x00'  # Pad with a zero byte if the length is odd

    s = 0
    for i in range(0, len(data), 2):
        w = (data[i] << 8) + data[i + 1]
        s = s + w

    # Add overflow bits to the sum
    s = (s >> 16) + (s & 0xFFFF)
    s = ~s & 0xFFFF

    return s

def icmp_create(icmp_type, icmp_code, icmp_id, icmp_sequence, data):
    """Create an ICMP packet with the given parameters and return it."""
    icmp_checksum = 0  # Initially, the checksum is set to 0
    icmp_header = pack("!BBHHH", icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_sequence)
    icmp_packet = icmp_header + data

    # Calculate the checksum
    icmp_checksum = checksum(icmp_packet)
    
    # Pack the header again with the correct checksum
    icmp_header = pack("!BBHHH", icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_sequence)
    return icmp_header + data

def IP(src, dst, count):
    #if len(sys.argv) > 3:
    #    src = sys.argv[1]
    #    dst = sys.argv[2]
    #    count   = int(sys.argv[3])

    # ip header fielss
    ip_ihl = 5
    ip_ver = 4
    ip_tos = 0
    ip_tos_len = 0 # Kernal will fill the correct total length
    ip_id = 54321  # ID of this packet
    ip_frag_off = 0
    ip_ttl = 64
    ip_proto = 1 
    ip_check = 0 # Kernal will fill the correct checksum
    ip_saddr = socket.inet_aton ( src ) # spoof the source ip if u want to
    ip_daddr = socket.inet_aton ( dst )

    # Icmp header 
    icmp_type = 8
    icmp_code = 0
    icmp_checksum = 0
    icmp_id = 0
    icmp_sequence = 0
    payload = b'!@#$%^&*() 1234567890'

    ip_ihl_ver = (ip_ver << 4) + ip_ihl

        # packing the ip header
    # the ! in the pack format string means network order
    ip_header = pack("!BBHHHBBH4s4s" , ip_ihl_ver, ip_tos, ip_tos_len, ip_id, ip_frag_off, ip_ttl, ip_proto, ip_check, ip_saddr, ip_daddr)
    icmp_header = icmp_create(icmp_type, icmp_code, icmp_id, icmp_sequence, payload)
    packet = ip_header + icmp_header
       
       # Request Sending
    print(f"PING  {dst} bytes of data.")    
    for i in range(count):
        sendsock.sendto(packet, (dst , 0))
        #print(f"Sending ICMP Packet to {dst}")

class ICMP(Structure):
    _fields_ = [
        ("type",		    c_ubyte),
        ("code",		    c_ubyte),
        ("checksum",	    c_ushort),
        ("id",		        c_ushort),
        ("sequence",        c_ushort)
        ]

def __new__(self, socket_buffer=None):
    return self.from_buffer_copy(socket_buffer)

def __init__(self, socket_buffer=None):
    self.src_address = socket.inet_ntoa(struct.pack("@I",self.src))
    self.dst_address = socket.inet_ntoa(struct.pack("@I",self.dst))
    pass


def parse_icmp_response(data):
    """Parse the ICMP part of the response and return it."""
    icmp_header = data[20:28]  # ICMP header starts at offset 20 in the IP header
    icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_sequence = struct.unpack('!BBHHH', icmp_header)
    return icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_sequence

def catch():
    try:
        while True:
            # Reading Packet
            resp = sendsock.recvfrom(65565)[0]
            # Creating an IP header from the first 20 bytes of the buffer
            #icmp = ICMP(resp[20:28])
            icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_sequence = parse_icmp_response(resp)
            print(f" bytes received from {dst} Sequence={icmp_sequence}")
    
    except KeyboardInterrupt:
        pass


if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("ping <src ip> <dst ip> <count>")
        sys.exit(1)

    src = sys.argv[1]
    dst = sys.argv[2]
    count = int(sys.argv[3])

    sendsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)    
    sendsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)   
    sendsock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)    

    # Threading
    ip_thread = threading.Thread(target=IP, args=(src, dst, count))
    catch_thread = threading.Thread(target=catch)

    ip_thread.start()
    catch_thread.start()

    ip_thread.join()
    catch_thread.join()


